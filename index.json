{
  "api/index.html": {
    "href": "api/index.html",
    "title": "Scripting API | VPE Documentation",
    "keywords": "This section will contain the scripting API documentation."
  },
  "api/VisualPinball.Unity.DeviceSwitch.html": {
    "href": "api/VisualPinball.Unity.DeviceSwitch.html",
    "title": "Class DeviceSwitch | VPE Documentation",
    "keywords": "Class DeviceSwitch Devices switches are switches within a device that are not directly linked to any game item. Inheritance System.Object DeviceSwitch Namespace : VisualPinball.Unity Assembly : VisualPinball.Unity.dll Syntax public class DeviceSwitch : object, IApiSwitch Constructors | Improve this Doc View Source DeviceSwitch(String, Boolean, SwitchDefault, Player) Declaration public DeviceSwitch(string name, bool isPulseSwitch, SwitchDefault switchDefault, Player player) Parameters Type Name Description System.String name System.Boolean isPulseSwitch VisualPinball.Unity.SwitchDefault switchDefault VisualPinball.Unity.Player player Properties | Improve this Doc View Source IsEnabled Indicates whether the switch is currently opened or closed. Declaration public bool IsEnabled { get; } Property Value Type Description System.Boolean | Improve this Doc View Source IsSwitchClosed Guesses whether the switch is closed or not. Declaration public bool IsSwitchClosed { get; } Property Value Type Description System.Boolean Remarks This is used in the trough inspector to render the switch states. We \"guess\", because in case the switch default is configurable, we don't actually know, because then it depends on each individual mapping. Methods | Improve this Doc View Source AddWireDest(WireDestConfig) Declaration public void AddWireDest(WireDestConfig wireConfig) Parameters Type Name Description VisualPinball.Unity.WireDestConfig wireConfig | Improve this Doc View Source DestroyBall(Entity) Declaration public void DestroyBall(Entity ballEntity) Parameters Type Name Description Unity.Entities.Entity ballEntity | Improve this Doc View Source ScheduleSwitch(Boolean, Int32) Schedules the switch to be enabled or disabled. Declaration public void ScheduleSwitch(bool enabled, int delay) Parameters Type Name Description System.Boolean enabled If true, closes mechanical switch or opens opto switch. If false, opens mechanical switch or closes opto switch. System.Int32 delay Delay in milliseconds | Improve this Doc View Source SetSwitch(Boolean) Enables or disables the switch. Declaration public void SetSwitch(bool enabled) Parameters Type Name Description System.Boolean enabled If true, closes mechanical switch or opens opto switch. If false, opens mechanical switch or closes opto switch. Events | Improve this Doc View Source Switch Event emitted when the switch opens or closes. Declaration public event EventHandler<SwitchEventArgs> Switch Event Type Type Description EventHandler < VisualPinball.Unity.SwitchEventArgs >"
  },
  "api/VisualPinball.Unity.FlipperApi.html": {
    "href": "api/VisualPinball.Unity.FlipperApi.html",
    "title": "Class FlipperApi | VPE Documentation",
    "keywords": "Class FlipperApi The scripting API of the flipper. Inheritance System.Object ItemApi < VisualPinball.Engine.VPT.Flipper.Flipper , VisualPinball.Engine.VPT.Flipper.FlipperData > FlipperApi Inherited Members ItemApi<Flipper, FlipperData>.Name ItemApi<Flipper, FlipperData>.Data ItemApi<Flipper, FlipperData>.IsColliderEnabled ItemApi<Flipper, FlipperData>.FireHitEvents ItemApi<Flipper, FlipperData>.HitThreshold ItemApi<Flipper, FlipperData>.GetPhysicsMaterial(Table) Namespace : VisualPinball.Unity Assembly : VisualPinball.Unity.dll Syntax public class FlipperApi : ItemApi<Flipper, FlipperData>, IApi, IApiInitializable, IApiHittable, IApiRotatable, IApiCollidable, IApiSwitch, IApiCoil, IApiWireDest, IApiColliderGenerator Methods | Improve this Doc View Source GetPhysicsMaterial(Table) Declaration protected override PhysicsMaterialData GetPhysicsMaterial(Table table) Parameters Type Name Description VisualPinball.Engine.VPT.Table.Table table Returns Type Description VisualPinball.Unity.PhysicsMaterialData Overrides VisualPinball.Unity.ItemApi<VisualPinball.Engine.VPT.Flipper.Flipper, VisualPinball.Engine.VPT.Flipper.FlipperData>.GetPhysicsMaterial(VisualPinball.Engine.VPT.Table.Table) | Improve this Doc View Source RotateToEnd() Enables the flipper's solenoid, making the flipper to start moving to its end position. Declaration public void RotateToEnd() | Improve this Doc View Source RotateToStart() Disables the flipper's solenoid, making the flipper rotate back to its resting position. Declaration public void RotateToStart() Events | Improve this Doc View Source Collide Event emitted when the flipper collided with the ball. Declaration public event EventHandler<CollideEventArgs> Collide Event Type Type Description EventHandler < VisualPinball.Unity.CollideEventArgs > | Improve this Doc View Source Hit Event emitted when the flipper was touched by the ball, but did not collide. Declaration public event EventHandler<HitEventArgs> Hit Event Type Type Description EventHandler < VisualPinball.Unity.HitEventArgs > | Improve this Doc View Source Init Event emitted when the table is started. Declaration public event EventHandler Init Event Type Type Description EventHandler | Improve this Doc View Source LimitBos Event emitted when the flipper comes to rest, i.e. moves back to the resting position. Declaration public event EventHandler<RotationEventArgs> LimitBos Event Type Type Description EventHandler < VisualPinball.Unity.RotationEventArgs > | Improve this Doc View Source LimitEos Event emitted when the flipper reaches its end position. Declaration public event EventHandler<RotationEventArgs> LimitEos Event Type Type Description EventHandler < VisualPinball.Unity.RotationEventArgs > | Improve this Doc View Source Switch Event emitted when the trigger is switched on or off. Declaration public event EventHandler<SwitchEventArgs> Switch Event Type Type Description EventHandler < VisualPinball.Unity.SwitchEventArgs > | Improve this Doc View Source Timer Declaration public event EventHandler Timer Event Type Type Description EventHandler"
  },
  "api/VisualPinball.Unity.html": {
    "href": "api/VisualPinball.Unity.html",
    "title": "Namespace VisualPinball.Unity | VPE Documentation",
    "keywords": "Namespace VisualPinball.Unity Classes DeviceSwitch Devices switches are switches within a device that are not directly linked to any game item. FlipperApi The scripting API of the flipper. ItemApi<TItem, TData> Base class for all item APIs. TroughApi A trough implements all known trough behaviors that exist in the real world."
  },
  "api/VisualPinball.Unity.ItemApi-2.html": {
    "href": "api/VisualPinball.Unity.ItemApi-2.html",
    "title": "Class ItemApi<TItem, TData> | VPE Documentation",
    "keywords": "Class ItemApi<TItem, TData> Base class for all item APIs. Inheritance System.Object ItemApi<TItem, TData> FlipperApi TroughApi Namespace : VisualPinball.Unity Assembly : VisualPinball.Unity.dll Syntax public abstract class ItemApi<TItem, TData> : object, IApi where TItem : Item<TData> where TData : ItemData Type Parameters Name Description TItem TData Item data type Constructors | Improve this Doc View Source ItemApi(TItem, Entity, Entity, Player) Declaration protected ItemApi(TItem item, Entity entity, Entity parentEntity, Player player) Parameters Type Name Description TItem item Unity.Entities.Entity entity Unity.Entities.Entity parentEntity VisualPinball.Unity.Player player | Improve this Doc View Source ItemApi(TItem, Player) Declaration protected ItemApi(TItem item, Player player) Parameters Type Name Description TItem item VisualPinball.Unity.Player player Properties | Improve this Doc View Source Data Declaration public TData Data { get; } Property Value Type Description TData | Improve this Doc View Source FireHitEvents Declaration protected virtual bool FireHitEvents { get; } Property Value Type Description System.Boolean | Improve this Doc View Source HitThreshold Declaration protected virtual float HitThreshold { get; } Property Value Type Description System.Single | Improve this Doc View Source IsColliderEnabled Declaration protected virtual bool IsColliderEnabled { get; } Property Value Type Description System.Boolean | Improve this Doc View Source Name Item name Declaration public string Name { get; } Property Value Type Description System.String Methods | Improve this Doc View Source GetPhysicsMaterial(Table) Declaration protected virtual PhysicsMaterialData GetPhysicsMaterial(Table table) Parameters Type Name Description VisualPinball.Engine.VPT.Table.Table table Returns Type Description VisualPinball.Unity.PhysicsMaterialData"
  },
  "api/VisualPinball.Unity.TroughApi.html": {
    "href": "api/VisualPinball.Unity.TroughApi.html",
    "title": "Class TroughApi | VPE Documentation",
    "keywords": "Class TroughApi A trough implements all known trough behaviors that exist in the real world. Inheritance System.Object ItemApi < VisualPinball.Engine.VPT.Trough.Trough , VisualPinball.Engine.VPT.Trough.TroughData > TroughApi Inherited Members ItemApi<Trough, TroughData>.Name ItemApi<Trough, TroughData>.Data ItemApi<Trough, TroughData>.IsColliderEnabled ItemApi<Trough, TroughData>.FireHitEvents ItemApi<Trough, TroughData>.HitThreshold ItemApi<Trough, TroughData>.GetPhysicsMaterial(Table) Namespace : VisualPinball.Unity Assembly : VisualPinball.Unity.dll Syntax public class TroughApi : ItemApi<Trough, TroughData>, IApi, IApiInitializable, IApiSwitchDevice, IApiCoilDevice, IApiWireDeviceDest Remarks A trough consists of two parts: The drain where the ball lands after it exists the playfield. In modern troughs this part does not exist, since the balls go directly into the trough. The ball stack , where balls are stored for games that hold more than one ball. Fields | Improve this Doc View Source EntryCoil Entry coil shoots the ball from the drain into the trough. Declaration public DeviceCoil EntryCoil Field Value Type Description VisualPinball.Unity.DeviceCoil Remarks Is null for VisualPinball.Engine.VPT.TroughType.ModernOpto and VisualPinball.Engine.VPT.TroughType.ModernMech | Improve this Doc View Source ExitCoil Triggers the kicker that ejects the ball. Declaration public DeviceCoil ExitCoil Field Value Type Description VisualPinball.Unity.DeviceCoil | Improve this Doc View Source JamSwitch The jam switch sits right above ball 1 and shortly enables and disables after eject. Declaration public DeviceSwitch JamSwitch Field Value Type Description DeviceSwitch Properties | Improve this Doc View Source EntrySwitch The entry switch. This is the switch that is closed when the ball lands in the drain. Declaration public DeviceSwitch EntrySwitch { get; } Property Value Type Description DeviceSwitch Remarks Is null for VisualPinball.Engine.VPT.TroughType.ModernOpto , all of modern's switches are in StackSwitch(Int32) . | Improve this Doc View Source NumStackSwitches How many stack switches there are available. Declaration public int NumStackSwitches { get; } Property Value Type Description System.Int32 Remarks The drain switch is not considered a stack switch. | Improve this Doc View Source UncountedDrainBalls The number of balls waiting to be drained because the drain slot is occupied. Once the drain slot is freed, i.e. the ball is kicked over into the ball stack, the next undrained ball enters the drain and this number is decremented by one. Declaration public int UncountedDrainBalls { get; } Property Value Type Description System.Int32 Remarks Usually, the gamelogic engine immediately frees the drain slot and this value should always be zero. | Improve this Doc View Source UncountedStackBalls The stack of a trough can hold an unlimited number of balls. This counts the number of balls in the stack additionally to those counted by the stack's switches. Declaration public int UncountedStackBalls { get; } Property Value Type Description System.Int32 Remarks Usually, games only have as many balls as stack switches and this value should always be zero. Methods | Improve this Doc View Source EjectBall() If there are any balls in the ball stack, eject one to the playfield. Declaration public bool EjectBall() Returns Type Description System.Boolean True if a ball was ejected, false if there were no balls in the stack to eject. Remarks This triggers any switches which the remaining balls would activate by rolling to the next position. | Improve this Doc View Source StackSwitch() Returns the switch for VisualPinball.Engine.VPT.TroughType.TwoCoilsOneSwitch multi ball troughs that only have one switch. Declaration public DeviceSwitch StackSwitch() Returns Type Description DeviceSwitch The stack switch | Improve this Doc View Source StackSwitch(Int32) Returns the stack switch at a given position for VisualPinball.Engine.VPT.TroughType.ModernOpto , VisualPinball.Engine.VPT.TroughType.ModernMech and VisualPinball.Engine.VPT.TroughType.TwoCoilsNSwitches troughs. Declaration public DeviceSwitch StackSwitch(int pos) Parameters Type Name Description System.Int32 pos Position, where 0 is the switch of the ball being ejected next. Returns Type Description DeviceSwitch Switch in the ball stack Events | Improve this Doc View Source Init Event emitted when the table is started. Declaration public event EventHandler Init Event Type Type Description EventHandler"
  },
  "CHANGELOG.html": {
    "href": "CHANGELOG.html",
    "title": "Changelog | VPE Documentation",
    "keywords": "Changelog This documents all notable changes to the Visual Pinball Engine and its dependent projects. Unreleased Built with Unity 2020.2 . Added Slow motion during gameplay ( #288 ). Lamp Manager ( #282 ). The VPE core is now also available on NuGet . VPE is now packaged and published on every merge! Native trough component ( #229 , #248 , #256 , Documentation ) Changed Plunger is now a coil device, meaning it can both be pulled back and fired through different inputs. Move render pipelines into separate repos ( #259 ) Put game-, mesh-, collision- animation data into separate components ( #227 , Documentation ) Fixed Fixed a few bugs in drag point gizmos ( #246 )"
  },
  "creators-guide/editor/advanced/camera-settings.html": {
    "href": "creators-guide/editor/advanced/camera-settings.html",
    "title": "Camera Settings | VPE Documentation",
    "keywords": "Camera Settings The editor camera controller is a tool designed to set different camera views during the editing and testing process. It allows the camera to be easily adjusted with a few sliders as well as allowing for the saving and loading of presets. The camera controller is setup to orbit around a focal point. While doing this it will automatically adjust the clipping planes on the camera to ensure the best quality shadows and highest precision sorting of transparent objects. Note In most 3D engines, a depth buffer us used for many rendering features such as shadows, transparency sorting and various post process effects. This buffer is a greyscale representation of the distance of a pixel from the camera. As such, it has a limited value range that must be spread to cover the entire scene. The larger the range, the less precision the buffer will have. By closely cropping the range, the precision can be increased. In using the camera controller this is handled automatically. If you add your own camera you will have to adjust this manually. Usage To use the camera controller, select the Camera scene object, which is at the very top of the hierarchy. In the inspector you will find a few sliders: Angle : Controls the angle of the camera to the table. A value of zero places the camera parallel to the table. A value of 90 places the camera perpendicular to the table. Offset XYZ : Moves the pivot point of the camera along the three world axis. X moves the camera left and right relative to where a player would stand. V moves it up and down and Z moves it forward and back. Angle , Distance and Orbit are always relative to this point. Distance : Moves the camera closer to or further away from the pivot point. This is used in conjunction with the FOV to frame the table in view. FOV : Sets the field of view of the camera. High values result in a wide field of view and more depth perspective. Low values narrow and flatten the view. Note Adjusting the distance and FOV together will control how much apparent depth there is to tge table. A wide field of view and low distance will give the table a lit of perspective and depth, but will be more challenging to fit in the view without clipping the front, or having a lot of space to the sides in the back. Conversely, moving the camera further away and lowering the FOV will remove much of the perspective allowing the table to fit more evenly in the frame. Orbit : Controls the camera angle in an orbit around the table. 0 and 360 are standing in front of the table, 90 is on the left, 270 to the right. Presets Camera presets are stored camera settings that allow you to rapidly switch between different camera views. This can be useful when developing a table to view specific areas or just to take pretty screenshots. The preset slider changes between the stored camera views. There are three views included by default. Any preset can be overwritten by changing the parameters and clicking the Save button. If Save is not pressed, the values will be lost when you cycle to a new preset. New presets can be made by adjusting the values and clicking Clone . This preset will be added to the presets at the end. You can delete any preset by setting the slider to that preset and clicking the Delete button."
  },
  "creators-guide/editor/coil-manager.html": {
    "href": "creators-guide/editor/coil-manager.html",
    "title": "Coil Manager | VPE Documentation",
    "keywords": "Coil Manager On a real pinball table most moving parts, including the flippers, are triggered by coils (also called solenoids ). In VPE it's the job of the gamelogic engine to trigger them when needed. Just as the coils are physically wired to the power driver board on a regular machine they can be virtually connected in VPE using the coil manager under Visual Pinball -> Coil Manager . Setup Every row in the coil manager corresponds to a logical wire going from a gamelogic engine output to the coil. As with switches, a single coil can be linked to multiple outputs, and an output can be linked to multiple coils. IDs The first column, ID shows the name that the gamelogic engine exports for each coil. Note As we cannot be 100% sure that the gamelogic engine has accurate data about the coil names, you can also add coil IDs manually, but that should be the exception. Description The Description column is optional. If you're setting up a re-creation, you would typically use this for the coil name from the game manual. It's purely for your own benefit, and you can keep this empty if you want. Destination The Destination column defines where the element in the following column is located. There are three options: Playfield lets you select a game element on the playfield that features the coil Device lets you choose a coil device , a mechanism which may include multiple coils, such as a trough . Lamp sets the coil to be configured in the lamp manager (see flashers in the lamp manager for more details). Element The Element column is where you choose which specifc element in the destination column should be activated. VPE can receive coil events for bumpers, flippers, kickers and plungers and coil devices. Note Bumpers are currently hard-wired, i.e. their switch will directly trigger the coil without going through the gamelogic engine. That means they don't need to be configured in the switch or coil manager. VPE will make this configurable in the future. Type In the Type column you can define whether the coil is single-wound or dual-wound. There's an excellent page about the differences in MPF's documentation . In short, dual-wound coils have two circuits, one for powering the coil, and one for holding it, while single-wound coils only have one. This changes how the coil powers off: For single-wound coils, VPE uses the same coil's events for powering on and off. For dual-wound coils, it uses the on event from the main coil and the off event from the hold coil. Hold Coil When the coil type is set to Dual-Wound , this column defines the hold coil event, i.e. the event on which the coil powers off. Dual-wound coils are fairly common. For example, Medieval Madness has the following dual-wound coils: From the Medieval Madness manual In VPE, the two flippers would map to the following configuration:"
  },
  "creators-guide/editor/lamp-manager.html": {
    "href": "creators-guide/editor/lamp-manager.html",
    "title": "Lamp Manager | VPE Documentation",
    "keywords": "Lamp Manager VPE uses the Unity game engine to accurately simulate the many types of lamps a real pinball machine might use, and connect them to the gamelogic engine. Lamps have a standard set of parameters, which can be tweaked in the editor. Lamps in a game are dynamic, so the gamelogic engine can toggle them, fade them, and even change their color. To link each of the playfield lamps to the gamelogic engine and configure how they behave during gameplay, the Lamp Manager is used. You can find it under Visual Pinball -> Lamp Manager . Note We use the terms lights and lamps as follows: With light we're referring to one of the Unity rendering engine's lights . It's a simulated light source which doesn't have to be a physical element on the table, but can also refer to the sun, some directional scene light, or other types of lighting used in the rendering. With lamp we're referring to a virtual \"bulb\" that is present on the table. It's a logical component VPE uses during gameplay, decoupled from the actual visual display. About Lamps Physical machines have many different implementations when it comes to lighting. The vast majority of solid state machines from the 1970s until the early 2010s used a lamp matrix , where lamps were addressed by row/column, and each individual lamp could only be fully on or off. Historically, incandescent light bulbs were used, which resulted in a brief warm-up period until they reached full brightness (and a cool-down period when turned off). To simulate this, VPE adopted the fade-in and fade-out properties for lights from Visual Pinball. Later machines used single colored LEDs that were each directly connected to a controller board (see also: Lights vs LEDs ). Unlike matrix lamps, the intensity of LEDs could be finely controlled by the game software. More recently, games started using RGB-LEDs that can change color as well as brightness during gameplay. In VPE, these can be handled in two different ways: As three single connections from the gamelogic engine, one for each color channel (this is what PinMAME provides, for example.) With a single RGB connection, where the gamelogic engine always provides the full color (used by MPF, or custom table logic.) Additionally, most pinball machines come with GI strands , which are a set of bulbs used for global illumination of the playfield. All lights in a strand are addressed at once, so one gamelogic GI strand maps to multiple lamps on the playfield. Finally, some high-powered lamps such as flashers may appear under the gamelogic engine's coil outputs , since those lamps operate on higher voltage and have the same properties as coils. Setup Every row in the lamp manager corresponds to a logical connection between the gamelogic engine and a lamp on the playfield. A lamp may be linked to multiple outputs, and an output can be linked to multiple lamps. IDs The first column, ID shows the name that the gamelogic engine exports for each lamp. Note Since we cannot be 100% sure that the gamelogic engine has accurate data about the lamp names, you can also add lamp IDs manually, but that should be the exception. Description The Description column is optional. If you're setting up a recreation, you would typically use this for the lamp name from the manual. It's purely for your own benefit, and you can leave this empty if you want. Destination The Destination column defines where the lamp is located. Currently, Playfield is the only option. Element Under the Element column, you choose which lamp among the game items on the playfield should be controlled. Type The Type column defines how the signal is interpreted by the lamp. This is important, because the gamelogic engine typically sends integer values to the lamp. There are four types: Single On|Off - Typically lamps from the lamp matrix. They can only be on or off. Receiving 0 will turn the lamp off, any other value will turn it on. Single Fading - Individual lamps which can be dimmed by the gamelogic engine. Received values can range from 0 to 255 , where 0 turns the lamp off, and 255 sets it to full intensity. RGB Multi - An RGB lamp that can change its color during gameplay. Lamps of this type receive three connections, one from each red, green and blue. Each color channel receives values as a fading lamp. RGB - An RGB lamp that receives its data from a single connection. This is the only mode where the lamp doesn't receive an integer, but an entire color value. R G B If the type of the previous column has been set to RGB Multi , here is where you link each wire to a color. Note that the red channel is always the one shown under the ID column, so changing the red link will also change the ID (and vice versa). Flashers When using a gamelogic engine that simulates real hardware such as PinMAME, high-powered lamps like flashers usually show up as coils connected to the driver board. To support this VPE allows routing coil outputs to lamps. For that, go to the Coil Manager and select Lamp as Destination : This will make the coil show up in the lamp manager where you can configure it: Note that you cannot change the ID of the lamp, because it's still linked to the coil. Also, removing or changing the coil destination will remove the entry from the lamp manager. Changing the ID in the coil manager will also update it in the lamp manager. GI Strands There is currently no special support for GI strands. In Visual Pinball, you can put GI lamps into a collection and address the whole collection at once via script. VPE doesn't have this feature yet. In order to hook up GI lamps, you can add an entry for each lamp and link all of them to the same ID. We'd like to make this easier in the future, so we're thinking of integrating this into the editor directly. Editor vs Runtime While editing the table in the Unity editor, you may find it helpful to disable lamps you're not editing. During runtime, VPE first turns all lamps off, then turns on the constant lamps, and then transfers control of the lamps to the gamelogic engine. If you are running the game in the editor, the lamp manager shows the lamp statuses in real time:"
  },
  "creators-guide/editor/multiple-tables.html": {
    "href": "creators-guide/editor/multiple-tables.html",
    "title": "Working with Multiple Tables | VPE Documentation",
    "keywords": "Working with Multiple Tables When working on a creation, you might want to load other tables to pick assets from. For that, Visual Pinball lets you open multiple tables allowing to switch and copy elements between them relatively quickly. With VPE, you can create or import multiple tables into your scene. VPE's manager panels will switch context when an element from a different table is selected in either the Scene view or the Hierarchy. Tip You can lock a manager window to the selected table by clicking on the small lock in the top right corner: Warning We don't have multi-table support during runtime yet. The idea is that in the future, you would be able to select which table is the runtime table. Warning Moving elements between multiple tables is not implemented yet, there is an open issue ."
  },
  "creators-guide/editor/switch-manager.html": {
    "href": "creators-guide/editor/switch-manager.html",
    "title": "Switch Manager | VPE Documentation",
    "keywords": "Switch Manager During gameplay, the gamelogic engine needs to know what is happening on the playfield. For that, real pinball tables have switches on the playfield that signal when a ball rolls over or settles in a certain position. These switches are also built into targets, bumpers, kickers, and other mechanisms (see Supported Game Mechanisms below). Wiring these switches up to the gamelogic engine with code can be a tedious process, so VPE provides a graphical interface where you can do it easily. If you've named them appropriately it can even guess which switch maps to which game item. You can open the switch manager under Visual Pinball -> Switch Manager . Switch matrix from Medieval Madness . Setup Imagine every row as a wire connecting the physical switch to the gamelogic engine. The relation between the two is 0..n -> 0..n , meaning you can link multiple switches to one input or a single switch to multiple inputs. IDs The first column ID shows the names of each switch that the gamelogic engine is aware of. There are two values to fill out here: The first, the dropdown value, is the ID that VPE will use to identify the switch. The second, an integer value, is the ID the gamelogic engine is using. This allows the gamelogic engine to make certain switches more explicit. For example, PinMAME has the same switch mapping all ROMs of a given game. These switches have a readable ID, which then translates into the numeric \"magic value\" that PinMAME uses internally. Global PinMAME switches of WPC games. Note As we cannot be 100% sure that the gamelogic engine has accurate data about the switch names, you can also add switch IDs yourself, but those should be the exception. NC The \"NC\" stands for Normally Closed . In short, enabling this inverts the value sent to the gamelogic engine. As for the long explanation, think about how switches work. Mechanical switches are usually normally open (NO) , meaning they are open by default and close when the ball rolls over them (or, if it's a button, when the button is pressed). But some switches behave differently. In opto-switches for instance, the light beam closes the circuit by default, and a ball rolling through it (and thus blocking the light) opens the switch. These type of switches are normally closed (NC) . Note In the very first screenshot, you'll notice that the trough switches are normally closed. This is because MM uses a modern trough with opto-switches. There is also the coin door we'd like to have closed by default and open the switch when the coin door is open. Description The Description column is optional. If you're setting up a re-creation, you would typically use this for the switch name from the game manual. It's purely for your own benefit, and you can keep this empty if you want. Source The Source column defines where the element in the following column originates. There are four options: Playfield lets you choose a game item from the playfield Input System lets you choose an input action from a pre-defined list, e.g. cabinet switches Constant sets the switch once at the beginning of the game to the given value. Device lets you choose a switch device containing the switch. Switch devices are mechanisms that include multiple switches, for example troughs . Element The Element column is where you choose which element triggers the switch. For Playfield sources, you can choose a game item that triggers switch events. Currently, VPE only emits switch events for items that would do so in real life, i.e. bumpers, flippers, gates, targets, kickers, spinners and triggers. Note We realize that you might want to use other game items like ramps and walls to emit switch events as well, and we will address this at some point, but for now we're keeping it simple. If Input System is selected, you choose which input action to use (it's an \"action\", because it's not an permanent key binding). Actions may have default key bindings, but the final bindings to a key or other input will be defined in the host application (the VPE player). If the source is a Device , then there are two values to select. The actual switch device, and which switch of that device should be connected to the gamelogic engine. Finally, if Constant is selected, you choose the value that will be permanently set at the beginning of the game. Pulse Delay Internally, VPE connects switches to events. For example, a trigger on the playfield has a Hit event, which occurs when the ball rolls into the trigger's collision zone, and an UnHit event when the ball leaves that zone. These two events close and open the trigger's switch. However, not all mechanisms behave like that. For example a spinner emits a single Spin event. So to prevent the switch from being closed indefinitely VPE automatically re-opens it after a given delay. We call that the Pulse Delay . \"Pulse\", because it gets triggered by one event and reopens after a brief delay. In most cases, you can leave the default delay of 250ms. What's important is that the gamelogic engine gets notified not too long after the switch was closed. Note that if pulse delay is set to 0, the switch will stay closed. Supported Game Mechanisms Below a list of game mechanisms that contain built-in switches. Closes Opens Bumper On ball collision After pulse delay Flipper On EOS, i.e. when the flipper reaches its end position When the flipper switch is opened, i.e. the flipper starts moving down again Gate When ball is passing through the gate When ball has passed through Target On collision After pulse delay Kicker When ball enters the kicker When ball's outside the kicker Spinner On each spin After pulse delay Trigger When the ball rolls over the trigger When the ball is outside of the trigger"
  },
  "creators-guide/editor/unity-components.html": {
    "href": "creators-guide/editor/unity-components.html",
    "title": "Unity Components | VPE Documentation",
    "keywords": "Unity Components When loading or creating a table in Unity, what you're creating is a hierarchy of GameObjects , the basic building blocks of Unity scenes. By default we group game items by their type when importing, but you can arrange them however you want. To give the GameObjects behavior during gameplay, we add components onto them. VPE comes with large number of components that are used to set up and control the game mechanisms of the table, and advanced programmers can contibute new ones. Note During runtime, VPE converts the GameObjects and components into entities in Unity's DOTS workflow . There are special components used to control this conversion which we call Authoring Components . If you've never heard about GameObjects or components, we recommmend you read through the links in the first two paragraphs. They are short, to the point, and a much better introduction than we could provide here. Components vs Game Items In Visual Pinball , components are what you see in the options panel when you click on a game item. You'll typically find sections for adjusting physical behavior, visual display, and geometric shape of the game item you're editing. Internally, all of these sections belong to the same game item. In VPE , we have separate components for each of these sections. There are four different types of components: The Main Component represents the actual game item. A Collider Component adds physical behavior to the game item. It defines how the item interacts with other objects, for example what bounciness, friction and randomness is applied to a pinball hitting the item. Mesh Components generate meshes, i.e. the geometry used to render the object on the playfield. The results are the procedurally generated 3d objects rendered in the scene. Animation components apply movement to the game item. If the entire object is moving (for example a flipper), that is handled by the collision component, but for items where only parts move (e.g. the plate of a gate, or the ring of a bumper) these components apply the movement to the GameObject. Let's look at a flipper: Here, we see the main component ( Flipper ), the collider component ( Flipper Collider ), and two mesh components ( Flipper Base Mesh and Flipper Rubber Mesh ) inside VPE compared to Visual Pinball. While the main and collider component sit on the base GameObject, each mesh component is on its own child GameObject. This is how Unity works - a GameObject only contains one component of each type. Note Internally, VPE still keeps a single set of data. That's why you see the collapsed Base Mesh , Rubber Mesh and Physics sections in the main component. When you change values there, the corresponding values in the other components will update at the same time. In general, you don't have to manually manage all this. When creating game items via the toolbox, the new GameObject will already have all the necessary components, as will the items created when importing a .vpx file. This separation of logic has a few advantages. First, it's more obvious how a game item behaves. No collider component? That means the game item is not collidable. No mesh component? It's (permanently) invisible. But there are other advantages, as you will see in the next section. Combining Components VPE allows you to mix and match components onto game items. For example, for a given game item, you could assign a collider or mesh from another type. The most common use case is replacing built-in meshes with primitives, removing the original mesh component and replacing it with a generated version. But there are other usages, like using a primitive collider on a rubber. You can also add multiple children with colliders (or meshes) for a game item. We call this parenting . The game item that overrides a given behavior is still created, but serves as a parent container to other game items. The advantage compared to Visual Pinball, where you would create individual game items, is that VPE treats them as one single logical entity. For example, VPE will automatically rotate a primitive flipper item when it's parented under a flipper, and events from multiple colliders will be emitted from the same parent object. Supported Combinations Not every game item can be parented to any other game item. It doesn't make much sense to use a flipper collider for a bumper. In fact, most of the combinations are unsupported. Here's what VPE does support so far: Supported Meshes Supported Colliders Supported Animators Bumper Bumper Base, Bumper Cap, Bumper Ring, Bumper Skirt, Primitive Bumper Bumper Ring, Bumper Skirt Flipper Flipper Base, Flipper Rubber, Primitive Flipper Gate Gate Bracket, Gate Wire, Primitive Gate Gate Wire Hit Target Hit Target, Primitive Hit Target Hit Target, Drop Target Kicker Kicker, Primitive Kicker Light Light, Primitive Plunger Flat Plunger, Plunger Rod, Plunger Spring Plunger Plunger Primitive Primitive Primitive, Ramp, Wall Ramp Ramp, Primitive Ramp Rubber Rubber, Primitive Rubber, Surface, Primitive Spinner Spinner Bracket, Spinner Plate, Primitive Spinner Spinner Plate Surface Surface, Primitive Surface, Primitive Trigger Trigger, Primitive Trigger Trigger Naming Conventions In order to maintain backward compatibility with Visual Pinball, VPE relies on naming conventions to parent one game item to another. There are two suffixes that have special meaning for VPE: _Mesh applies the game item's mesh to its parent _Collider applies the game item's collider to its parent For example, if in Visual Pinball you name a primitive LeftFlipper_Mesh , VPE will look for a LeftFlipper game item and replace its mesh with the mesh of that primitive. In other words, it will parent LeftFlipper_Mesh to LeftFlipper and disable LeftFlipper 's original mesh. Another example: If in Visual Pinball you name a rubber LeftSlingshot and two primitives LeftSlingshot_Collider_Soft and LeftSlingshot_Collider_Hard , VPE will disable the collider of LeftSlingshot and use both the other colliders instead. During gameplay when the ball hits either LeftSlingshot_Collider_Soft or LeftSlingshot_Collider_Hard , the Hit event will be emitted on LeftSlingshot . Warning When you export to .vpx and you have parented items that don't follow the naming convention, the parenting will get lost when re-importing the table into VPE. In the future, VPE may offer to (or even automatically) rename the parented children on export, but that's still on our TODO list. Visibility In order to determine whether a game item is visible, VPE looks at the hierarchy and the mesh components of its GameObject. If a game item has no mesh component, its automatically set to invisible . It's also invisible if the GameObject is set to inactive (the checkbox at the top left in the Inspector)."
  },
  "creators-guide/editor/wire-manager.html": {
    "href": "creators-guide/editor/wire-manager.html",
    "title": "Wire Manager | VPE Documentation",
    "keywords": "Wire Manager Using the Switch Manager , you can wire playfield and cabinet switches to the Gamelogic Engine . Similarly, the Coil Manager and Lamp Manager let you connect playfield elements to the outputs of the Gamelogic Engine. The Wire Manager allows you to bypass the gamelogic engine and connect switches directly to coils and lamps. This can be useful for debugging, but also for game logic that might not be covered by the gamelogic engine. You can open the wire manager under Visual Pinball -> Wire Manager . Setup Every row in the wire manager's table corresponds to a connection between a switch and an element that takes an input. You can connect multiple switches to one element or a single switch to multiple elements. In the following, we call the switch the source and the element it is connected to the destination . Description The first column Description is optional. It can help better organize all the connections, but can be left empty if you want. Source The Source column defines the type of source you are connecting to. There are four types: Playfield lets you select any game item that qualifies as a source from the playfield. Input System lets you select an input action from a pre-defined list, e.g. cabinet switches. Constant sets the destination to a constant value. Device lets you select a source device. Such devices are mechanisms that include multiple sources, for example troughs . Source Element The Source Element column is where you select which element acts as the source. For Playfield sources, you can select a game item that triggers switch events. Currently, VPE emits switch events for items that would do so in real life, i.e. bumpers, flippers, gates, targets, kickers, spinners and triggers. If Input System is selected, you select which input action to use. Actions may have default key bindings, but the final bindings to a key or other input will be defined in the host application (the VPE player). If the source is a Device , then there are two values to select. The actual source device, and which switch of that device should be connected to the gamelogic engine. Finally, if Constant is selected, you select the value that will be permanently set at the beginning of the game. This might me useful for lamps that are always on. Destination Under Destination you can select the type of the element that will receive the switch changes. There are two types to choose from: Playfield lets you select any game item that qualifies as a destination from the playfield Device lets you choose a destination device. Such devices are mechanisms that include multiple coils or lamps, for example troughs . Destination Element The Destination Element column is where you select which specific element in the destination column should receive switch changes. If Device was selected in the previous column, both the actual device and the element within the device have to be selected. Pulse Delay Internally, VPE connects switches to events. Some switchable game items only emit the switch closed event. Such items are spinners and targets. These are elements where the re-opening of the switch does not have any semantic value. In order for those to not stay closed forever, VPE closes them after a given delay. We call this the Pulse Delay . This field is only visible if the input source is a pulse-driven source."
  },
  "creators-guide/introduction/features.html": {
    "href": "creators-guide/introduction/features.html",
    "title": "Features | VPE Documentation",
    "keywords": "Features This section documents what's already working. If it's not, then that's a bug, and you should let us know . Materials We convert Visual Pinball's materials to materials compatible with the active render pipeline. That means materials look similar to Visual Pinball by default, while there's still a lot of potential left to tweak materials using the full material configuration of Unity. Bord's \"Viking\" rendered in VPX (left) and imported as-is in VPE's built-in renderer (right). Meshes Visual Pinball dynamically generates meshes for most of the game items. VPE has ported that code and does the same when loading a table. A rubber mesh generated in the editor Physics We have nearly finished porting Visual Pinball's physics engine to VPE. That means the ball and flipper behavior should be identical to Visual Pinball. This includes physics-based movement from flippers, gates and spinners, as well as animated targets, triggers and plungers. Events The physics engine emits the same events as Visual Pinball. That means you can subscribe to collision events and other game item-specific events. For example, for subscribing to the flip event of a flipper, you would do: table.Flipper(\"LeftFlipper\").LimitEos += (sender, args) => { // do something! }; Note While it's not clear how we'll handle scripting, most events can probably be configured visually in the editor and don't need to be handled via scripting. Cross Platform Unity supports a lot of platforms . Our continuous integration builds for Windows (x86/x64), macOS (x64) and Linux (x64). Besides Windows, some of our developers work on macOS, and we regularly test on Linux as well. File Format We care about backwards-compatibility to Visual Pinball. VPE can read and write .vpx files and supports the full data set. This means that you can load a table into VPE, edit it, export it to .vpx and load it back into Visual Pinball. Note VPE will at some point need to save additional data that isn't available in Visual Pinball. However, the .vpx structure is like a virtual file system, so we can do that without breaking backwards-compatibility. Editor Extensions Unity allows full editor customization. So we're adding the managers, panels, and toolboxes from Visual Pinball into the Unity editor: What you're seeing here is the toolbox as well as a few manager windows we've ported: Material Manager Image Manager Layer Manager Inspector acting as VP's Options Panel You can dock these as you wish, or even undock them and move them to another monitor. Not in the above screenshot but also ported are: Collections Manager Sound Manager VPE is also able to edit drag points. Moving those (in 3D!) re-generates the mesh on the fly: Lastly, we can visualize the colliders of any object. This can be useful to debug, and also to check whether you may have objects set to collide which actually shouldn't (or vice versa)! Patching System There are common patterns for VPX tables that are obsolete in VPE. For instance, VPE doesn't need a flipper shadow mesh, because it can do dynamic lighting out of the box. For that reason, we have a simple but sophisticated patcher system that allows us to apply changes to a table when imported. Of course the changes don't apply to the table data itself but to how we convert it into the Unity scene. You can read more about it here . Missing Features There are some things you might expect to work, but don't, because they're not yet implemented. Here's an incomplete list of those things. Key Assignments Currently, we grab left and right shift and map it to LeftFlipper and RightFlipper respectively. If the flippers are named differently, it doesn't work. VPE will provide a simple mapping mechanism where authors can link semantic key events to table logic and users can link keyboard keys to those key events. Performance When building the table, performance is okay but still not satisfactory. We think we can still do better. Runtime Import Right now, when you \"build\" your game and run it, Unity will compile it into binary assets. We want to avoid authors distributing those binaries, because they hide how things are done prevent further modding by other creators. Both of these aspects are crucial in building an ecosystem, so the goal is to only compile the player itself and load the tables at runtime. Ball Destruction Currently balls can't be destroyed during gameplay, so every drain will just leave them on the table, resulting in poor performance. Planned Features This section will at some point contain a list of major new features."
  },
  "creators-guide/introduction/overview.html": {
    "href": "creators-guide/introduction/overview.html",
    "title": "Overview | VPE Documentation",
    "keywords": "Overview The Visual Pinball Engine (which we call \"VPE\") is an open source pinball simulator that you can use to create pinball games for Windows, macOS, and Linux. It's based on the famous Visual Pinball (often abbreviated \"VP\", or \"VPX\" for its latest version 10) meaning VPE's physics simulation matches that in VPX, and it can read and write the same file format. VPE uses Unity for its underlying game architecture. Unity is one of the leading cross-platform game engines and provides VPE with an advanced render pipeline that produces high-quality visuals and is continuously maintained and updated to work with new hardware features. Unity also comes with an amazing editor, which VPE extends to make the table creation process as easy as possible. An imported .vpx file in VPE, using Unitys' High Definition Render Pipeline. Note Technically, VPE is what we call a \"library\". A library is not executable per se, because it needs a host application. We will provide such a host application in the future, but for now you will need to create a new Unity project and add VPE as a package in order to run it. Audience This documentation is mainly aimed at table creators (\"authors\"). Since it covers table scripting as well, it also contains code-related documentation. VPE is currently not in a state where it is usable by the general public (\"players\"). Documentation about how to setup VPE to play will follow at a later stage."
  },
  "creators-guide/manual/gamelogic-engine.html": {
    "href": "creators-guide/manual/gamelogic-engine.html",
    "title": "Gamelogic Engine | VPE Documentation",
    "keywords": "Gamelogic Engine When playing a pinball game, some part of the table is driving the gameplay, i.e. deciding when to flip a coil, turn on a light, show something on the DMD, and so on. In VPE, we call this the Gamelogic Engine . The gamelogic engine is purely gameplay driven. It gets input from switches, computes what will happen next, and updates the hardware components of the table. It does not handle game mechanics, which are about simulating the hardware behavior of the table - it just toggles it. Classic examples of gamelogic engines are MPF and PinMAME . Note Let's take a spinning wheel on the playfield as an example. The game logic engine's job is to know when to turn it on and off. The game mechanics component of the spinning wheel is about rotating the actual playfield element with the right speed, acceleration, and handle ball collisions with a given friction. At the moment it's still unclear how VPE will deal with game mechanics. Initially, we will ship a bunch of game mechanics ready to use, and the future will tell how authors can create their own. In Visual Pinball, the gamelogic engine is part of the table script, which in most cases uses VPM to drive the game. So a part of the table script is about piping data into VPM and handling its outputs (lamp changes, coil changes, and so on). Since VPE defines a clear API (like a contract) between the table and the gamelogic engine, we can provide tools to make this easy for you. Currently, VPE provides: A Switch Manager A Lamp Manager A Coil Manager These tools provide a graphical user interface where you can link playfield elements to the gamelogic engine and configure them. Ultimately, that means if your table uses an existing gamelogic engine like MPF or PinMAME, and the table doesn't contain any exotic game mechanics, that's all you need to do. You can set up your table without a single line of code!"
  },
  "creators-guide/manual/manual.html": {
    "href": "creators-guide/manual/manual.html",
    "title": "Manual | VPE Documentation",
    "keywords": "Manual This section will document the following: Game Items Pinball Mechanisms Scripting Physics Plugins"
  },
  "creators-guide/manual/mechanisms/flippers.html": {
    "href": "creators-guide/manual/mechanisms/flippers.html",
    "title": "Flipper | VPE Documentation",
    "keywords": "Flipper Flippers. They flip. You can program them too !"
  },
  "creators-guide/manual/mechanisms/troughs.html": {
    "href": "creators-guide/manual/mechanisms/troughs.html",
    "title": "Troughs / Ball Drains | VPE Documentation",
    "keywords": "Troughs / Ball Drains If you are unfamiliar with ball troughs, have a quick look at MPF's documentation , which does an excellent job explaining them. VPE comes with a trough mechanism that simulates the behavior of a real-world ball trough. This is especially important when emulating existing games, since the gamelogic engine expects the trough's switches to be in a plausible state, or else it may have errors. Creating a Trough When importing a .vpx file that doesn't have any troughs (which is likely, because Visual Pinball doesn't currently handle them in the same way as VPE) or creating a new table, VPE will automatically add a main trough to the root of the table. In order to create a trough manually, click on the Trough button in the toolbox. Linking to the Playfield To interact with the game, you must set up an input switch to drain the ball into the trough, and an exit kicker to release a new ball from the trough. This terminology may seem weird, since the ball exits the playfield when draining, but from the trough's perspective, that's where the ball enters . You can setup these links under Playfield Links by selecting the trough in the hierarchy panel and linking them to the desired items using the inspector. Note Both the input switch and the exit kicker are not related to the gamelogic engine. Their goal is purely to link the physics simulation to the trough logic, whose behavior is not physically simulated. Many games do have an input switch (which we call drain switch ) and an exit kicker (we that one eject coil ). They are simulated by the trough itself and show up in the switch- and coil manager under the trough device. The inspector also lets you configure other options: Ball Count defines how many balls the trough holds when the game starts. Switch Count sets how many ball switches are available. This is usually the same number as the ball count. The drain switch and the jam switch are excluded from this count. Has Jam Switch defines if the trough has a jam switch. This switch is often called eject switch as well. Roll Time sets how long it takes the ball to roll from one switch to the next. Kick Time defines how long it takes the ball to get kicked from the drain into the trough. Transition Time is only relevant for opto switches and defines how long the switch closes between balls. Trough Types VPE supports several variants of troughs found on real machines. You can configure the behavior of the trough by changing the Type in the inspector when the trough is selected in the hierarchy. In this section we'll again link to the excellent MPF documentation explaining each of the different types. We'll also provide an animation of the trough inspector during gameplay showing how the switches and coils behave in real time. Modern Mechanical Modern troughs with mechanical switches are covered by this type. The ball drains from the playfield directly into the ball stack, and every ball slot has an associated switch. When a ball gets ejected, the remaining balls move down simultaneously to the next position. During that movement, their switches get first opened and then closed again when they reach the next position. The time of this movement is defined by Roll Time . The animation on the right shows a 6-ball trough filled with three balls. It starts by ejecting a ball, followed by draining that ball, rolling back onto the stack. Modern Opto Modern troughs with optical switches work similar similar to their mechanical counterparts. However there are two differences: Opto switches have the inverse value of mechanical switches. That means per default, an opto switch is closed , and when a ball rolls through, it opens. It's kind of logical, because the ball blocks the beam of light thus opening the circuit, while a mechanical switch gets closed by the ball's weight. Timings are different. When a ball approaches an opto switch, the switch gets triggered as soon as the ball's front hits the beam, while a mechanical switch gets triggered when the ball's center is over it. This results in very short closing times when the ball stack moves to the next position after a ball eject. We call this closing time the transition time - it's the time during stack transition when all switches briefly close. Like before, the animation shows a 6-ball trough filled with three balls. It starts by ejecting a ball, followed by draining that ball, rolling back onto the stack. Note When a transition time is set to 0 , only the first and the last switch of the stack change value (as opposed to each position opening and closing immediately). Two coils and multiple switches Troughs of this type can be found in older machines from the 80s and early 90s. They consist of two parts: A drain, the ball rolls into when leaving the playfield A ball stack, where the out of play balls are held. In terms of switches, they still include a switch per ball in the stack, but also an additional drain switch to trigger kicking the ball from the drain into the stack. The animation shows a 6-ball trough filled with three balls. It starts by ejecting a ball, followed by draining that ball. The ball stays in the drain until the entry coil activates, which makes the ball roll over to the ball stack. Two coils and one switch A trough can also have only one switch in the ball stack. Instead of a Switch Count like the previous types, you select a Switch Position , which is the position in the ball stack at which the ball farthest away from the eject coil sits. The animation shows a 6-ball trough filled with six balls. It starts by ejecting a ball, followed by draining that ball. The ball stays in the drain until the entry coil activates, which makes the ball roll over to the ball stack. Classic single ball A single ball trough may work with or without a shooter lane. The principle is simple: After draining, the ball is kept on the drain coil, which ejects the ball either directly into the plunger lane or back onto the playfield. The animation shows single ball trough that ejects a ball and drains it a few seconds later. Switch Setup The number of simulated switches in the trough depends on the type of trough and the Switch Count property in the inspector panel. For recreations, you can quickly determine the number of trough switches by looking at the switch matrix in the operation manual, it usually matches the number of balls installed in the game. To configure the switches, open the switch manager and add the trough switches if they're not already there. For Destination select \"Device\", under Element , select the trough you've created and which switch to connect. For a modern five-ball trough, it will look something like this: Coil Setup VPE's trough supports up to two coils, an entry coil which drains the ball from the outhole into the trough, and an eject coil which pushes a new ball into the plunger lane. To configure the coils, open the coil manager , find or add the coils, and link them to the trough like you did with the switches: Note Depending on which trough type is set, different coils and switches show up under the trough device."
  },
  "creators-guide/setup/installing-vpe.html": {
    "href": "creators-guide/setup/installing-vpe.html",
    "title": "Installing VPE | VPE Documentation",
    "keywords": "Installing VPE Unity In order to start creating or tweaking tables with VPE, the first thing you'll need to install is Unity . You will need a developer account, which is free. Note As long as you don't use VPE for a game that makes $100K or more in revenue or funding a year, the free Personal plan is sufficient for you. Unity uses an application called Unity Hub to update itself and provide quick access to your projects. The install process is straight-forward and documented here if you run into troubles. When installing Unity, use the latest 2020.2 version. You can leave all the other options unchecked. Once Unity is downloaded and installed, you'll need to create a new project. Unity has multiple render pipelines, and you'll be asked which render pipeline to use in your project: You'll have the choice between: 2D - For 2D games. VPE doesn't support this renderer. 3D - Unity's original built-in renderer. High Definition RP - Unity's new HDRP , used for high-end platforms. Universal Render Pipeline - Unity's URP is aimed at mobile and low-end platforms. We recommend using HDRP. It's not as mature as the built-in renderer, but it's able to achieve better visuals, and it's what Unity will be focusing on in the future. Note If you're just creating a throw-away project for testing out gameplay, the built-in renderer is more tested and faster to set up. We also support the URP, but it's not as well tested as the other two pipelines. Next, enter a project name and a location for your project. We recommend putting the render pipeline into the name, because in the future you might test out other pipelines and thus need to create additional projects. Tip We recommend creating a VPE folder in your user directory (which is called %userprofile% ), to contain all the VPE-related files. In this example that would be %userprofile%\\VPE\\Test Table - HDRP , which usually resolves to C:\\Users\\{username}\\VPE\\Test Table - HDRP . You're of course free to set this up however you want, but that's what we'll be referring to in the rest of the documentation. Clicking Create launches the Unity editor, pulls in all the dependencies for the new project, and compiles them. This can take a minute or two. HDRP Setup If you create an HDRP project, Unity provides you with a sample scene: The sample scene is awesome but huge, so we're going to discard it and create a new one. Click on File -> New Scene and select the Basic Indoors (HDRP) template. Save it in your Assets/Scenes folder as TestTable.unity . In this scene there's a plane that will Z-fight with our imported table later. Select it in the Hierarchy and move it down a little by setting the Y Position under Transform in the Inspector to -0.1 . Your scene should now look like this: Hit Ctrl+S to save your scene. VPE Source Code Now you have your project and scene set up, let's bring VPE into the project. Go to the GitHub page and download the source code . You can do that by clicking on the green Code button, and choosing Download ZIP . As mentioned above, we recommend extracting this into the VPE\\VisualPinball.Engine folder. Now, since we're using the High Definition Render Pipeline, we need to download another package which contains the rendering code. This package is part of VPE but lives in a different repository. Like before, download and extract it to your VPE folder. Your structure should now look something like this: In Unity, go to Window -> Package Manager . Click on the \"plus\" icon on the top left corner of the window, and choose Add package from disk . Choose package.json in the root folder of the extracted VPE source code. This will take a moment as Unity downloads and compiles all of VPE's dependencies. If during this time, you see the following warning: Click Yes . When complete, you should now have a Visual Pinball menu in the editor. Now do the same for the HDRP package. If everything went okay, you should now have these two packages showing up in the Package Manager: So let's import a table !"
  },
  "creators-guide/setup/running-vpe.html": {
    "href": "creators-guide/setup/running-vpe.html",
    "title": "Running VPE | VPE Documentation",
    "keywords": "Running VPE Now we can get begin with some simple game play. Open Visual Pinball, create a new \"blank\" table, and save it somewhere. In Unity, go to Visual Pinball -> Import VPX and choose the new .vpx file. You should now see Visual Pinball's blank table in the Editor's scene view: Now, we don't see much of our table. That's because the scene view's camera doesn't really point on it. Using the right mouse button in the Scene View and the A W S D keys while keeping right mouse button pressed, fly somewhere you have a better view of the table. Tip Check Unity's documentation on Scene view navigation for a more complete list of ways to move the camera around the scene. Now that we have the camera of the scene view somewhat aligned, we still can't see much! These orange artifacts are what Unity calls Gizmo Icons . They are enabled by default, and since VPE uses icons for its playfield elements, they are all over the place. In order to hide them, click on Visual Pinball -> Editor -> Disable Gizmo Icons . Since a pinball table is a relatively small object, the remaining icons are huge when working on a table, so click on the Gizmos dropdown in the scene view and use the top slider to shrink them down a bit. And while we're at it, choose Visual Pinball -> Editor -> Setup Layouts to populate a bunch of pre-made editor layouts that give you easy access to the tooling we've added to the editor. Now that's better! The view in the scene tab is not the camera used in game. The Scene View really allows you to fly anywhere, zoom in on things you're working on, switch from orthagonal view to perspective, and so on. It's where you get work done. During game play, another camera is used. It's the one already in your scene hierarchy (called Main Camera ), and you can look through it by switching to the Game View window. This camera can be moved using Unity's gizmos , by selecting it in the hierarchy and moving and tilting it around. Tip A quick way to fix the game camera is to align it with the scene view camera. To do that, select the camera in the hierarchy, then click on the GameObject menu and select Align with view . One last thing we need to do before playing is enable version 2 of the Hybrid Renderer we're using. Go to Edit -> Project Settings , select Player on the left, scroll down a bit on the right and add ENABLE_HYBRID_RENDERER_V2 under Script Define Symbols . Then click on Apply and close the window. Let's start the game by clicking on the play button. This will run your scene. Test that the shift keys move the flippers. ENTER will launch a ball. If you expand Table1 in the hierarchy and select the Trough , you can watch its status in the inspector in real time. Cool! You can also right-click on the scene view tab and select Maximize . Tip If you want to enter play mode more quickly, you can check the experimental play mode option described here . One last thing: The game view is pretty static now. You can change that by dropping an orbit script on the camera that lets you rotate and zoom in. If you're a Unity beginner, that would be your first exercise!"
  },
  "creators-guide/setup/updating-vpe.html": {
    "href": "creators-guide/setup/updating-vpe.html",
    "title": "Updating VPE | VPE Documentation",
    "keywords": "Updating VPE VPE is under heavy development, so it's frequently updated, usually multiple times per week. In order to not have to delete your existing VisualPinball.Engine folder and download and extract the code each time, we recommend using git. Git is a distributed version control system. It's very sophisticated but can also be a bit overwhelming to use. However, with the cheat sheet below you should be able to handle it. First you need to download git . Make sure it's in your PATH environment variable. There are free GUIs for git such as Fork , GitKraken or Source Tree , but we'll focus on the command line version on Windows here. Linux and macOS are similar but use a command shell or terminal window. Open a command prompt by pressing the Windows key and typing cmd , followed by enter. Make sure that git is installed by typing git --version . This should return something like git version 2.18.0.windows.1 . Next, go to the folder where you want to have VPE installed. If there is already a folder where you've extracted VPE from before, delete it. Following the recommended file structure, you would type: cd %userprofile%\\VPE git clone https://github.com/freezy/VisualPinball.Engine.git git clone https://github.com/freezy/VisualPinball.Unity.Hdrp.git This downloads the latest version of VPE into VisualPinball.Engine and VisualPinball.Unity.Hdrp respectively and keeps a link to GitHub. In the future, if you want to update VPE, it's simply a matter of going into the folder and \"pull\" the changes: cd %userprofile%\\VPE\\VisualPinball.Engine git pull cd ..\\VisualPinball.Unity.Hdrp git pull However, you might have experimented in the VPE folder to test out stuff, and git complains it can't update. Here is a way to discard all local changes and pull in what's on GitHub: git fetch --prune git checkout -- ** git reset --hard origin/master Warning Should you have committed changes (as in, you've developed something, and added and commited it to git), this will also discard those changes. But if you have done that you're probably a seasoned developer and know what you're doing, right? :)"
  },
  "creators-guide/vpe.html": {
    "href": "creators-guide/vpe.html",
    "title": "Features | VPE Documentation",
    "keywords": "Features Tutorial VPE Manual Game Items Pinball Mechanisms Scripting Physics Plugins About VPE About this Documentation Authors License and Copyright FAQ Glossary Contributing to VPE"
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome | VPE Documentation",
    "keywords": "Welcome to the documentation of the Start here with the creator's guide . Be aware we're at the very beginning of writing documentation. You'll see weird content."
  }
}